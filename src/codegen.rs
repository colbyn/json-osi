use std::collections::BTreeSet;
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

use crate::ir::{Field, Ty};

pub struct Codegen {
    out: String,
    used: BTreeSet<String>, // ensure stable, unique names per node path
}

impl Codegen {
    pub fn new() -> Self {
        Self {
            out: String::new(),
            used: BTreeSet::new(),
        }
    }
    pub fn into_string(self) -> String { self.out }

    pub fn emit(&mut self, root: &Ty, root_name: &str) {
        self.header();
        self.emit_null_type();
        self.walk(root, &mut Vec::new(), root_name.to_string());
    }

    fn header(&mut self) {
        // No module aliasing; fully qualified paths in all generated code.
        self.out.push_str(
r#"// AUTOGENERATED: strict types + deserializers (fully-qualified paths)
"#
        );
                self.out.push_str(
r#"// F64 tolerance helpers (absolute + relative)
const __ABS_TOL: f64 = 1e-12;
const __REL_TOL: f64 = 1e-12;

#[inline]
fn __tol(b: f64) -> f64 {
    let t = if __ABS_TOL > __REL_TOL * b.abs() { __ABS_TOL } else { __REL_TOL * b.abs() };
    if t.is_finite() { t } else { 0.0 }
}

#[inline] fn __ge_f64(x: f64, b: f64) -> bool { x + __tol(b) >= b }
#[inline] fn __le_f64(x: f64, b: f64) -> bool { x <= b + __tol(b) }
"#
        );
    }

    fn emit_null_type(&mut self) {
        self.out.push_str(
r#"#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Null;

impl<'de> ::serde::Deserialize<'de> for Null {
    fn deserialize<D>(de: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        // Accept only explicit null
        struct V;
        impl<'de> ::serde::de::Visitor<'de> for V {
            type Value = Null;
            fn expecting(&self, f:&mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "null")
            }
            fn visit_unit<E>(self) -> ::std::result::Result<Null, E>
            where
                E: ::serde::de::Error
            {
                Ok(Null)
            }
            fn visit_none<E>(self) -> ::std::result::Result<Null, E>
            where
                E: ::serde::de::Error
            {
                Ok(Null)
            }
        }
        de.deserialize_option(V)
    }
}
"#
        );
    }

    fn unique(&mut self, base: &str) -> String {
        let mut n = base.to_string();
        let mut i = 1;
        while self.used.contains(&n) {
            n = format!("{base}{i}");
            i += 1;
        }
        self.used.insert(n.clone());
        n
    }

    fn walk(&mut self, t: &Ty, path: &mut Vec<String>, hint: String) -> String {
        match t {
            Ty::Nullable(inner) => {
                let inner_name = self.walk(inner, path, hint);
                format!("::core::option::Option<{inner_name}>")
            }
            Ty::Null => "Null".into(),
            Ty::Bool => "bool".into(),
            Ty::Integer { .. } => self.emit_int_newtype(t, path, &hint),
            Ty::Number  { .. } => self.emit_num_newtype(t, path, &hint),
            Ty::String  { .. } => self.emit_string_kind(t, path, &hint),

            Ty::ArrayList { item, .. } => {
                let inner = self.walk(item, path, format!("{hint}Item"));
                format!("::std::vec::Vec<{inner}>")
            }

            Ty::ArrayTuple { elems, min_items, max_items } => {
                let type_name = self.unique(&to_type_name(&hint));

                // materialize field types
                let mut fields = ::std::vec::Vec::with_capacity(elems.len());
                for (i, e) in elems.iter().enumerate() {
                    let mut child = self.walk(e, &mut path_with(path, i), format!("{hint}{i}"));
                    let col_nullable = matches!(e, Ty::Nullable(_));
                    if (((i as u32) >= *min_items) || col_nullable) && !is_option_type(&child) {
                        child = format!("::core::option::Option<{child}>");
                    }
                    fields.push(child);
                }

                // exact arity
                if min_items == max_items {
                    let req = *min_items as usize;
                    self.emit_len_fixed_tuple(&type_name, &fields, req);
                    return type_name;
                }

                // lenient (min..=max) tuple
                self.emit_len_range_tuple(&type_name, &fields, *min_items as usize, *max_items as usize);
                type_name
            }

            Ty::Object { fields } => {
                let type_name = self.unique(&to_type_name(&hint));
                self.out.push_str("#[derive(Debug, ::serde::Deserialize)]\n");
                self.out.push_str("#[serde(deny_unknown_fields)]\n");
                self.out.push_str(&format!("pub struct {} {{\n", type_name));
                for Field { name, ty, required } in fields {
                    let fname = to_field_name(name);
                    let mut ty_str = self.walk(ty, path, format!("{hint}{}", to_type_name(name)));
                    if !*required {
                        ty_str = format!("::core::option::Option<{ty_str}>");
                    }
                    self.out.push_str(&format!("    pub {}: {},\n", fname, ty_str));
                }
                self.out.push_str("}\n\n");
                type_name
            }

            Ty::OneOf(arms) => {
                // Enum wrapper with try-each-arm using ::serde_json::from_value
                let type_name = self.unique(&to_type_name(&hint));
                let mut var_names = ::std::vec::Vec::new();
                let mut arm_types = ::std::vec::Vec::new();
                for (i, a) in arms.iter().enumerate() {
                    let v_name = format!("V{}", i);
                    var_names.push(v_name);
                    arm_types.push(self.walk(a, &mut path_with(path, i), format!("{hint}Alt{}", i)));
                }
                self.emit_union_enum_simple(&type_name, &var_names, &arm_types);
                type_name
            }

            Ty::Never => "Null".into(), // unreachable fallback
        }
    }

    // ---- tuples ----

    fn emit_len_fixed_tuple(&mut self, name: &str, field_types: &[String], required_len: usize) {
        self.out.push_str(&format!("/// tuple len={} (required exactly {})\n", field_types.len(), required_len));
        self.out.push_str(&format!("#[derive(Debug)]\npub struct {}(\n", name));
        for f in field_types {
            self.out.push_str(&format!("    pub {},\n", wrap_tuple_field(f)));
        }
        self.out.push_str(");\n\n");

        // one-pass visitor: read exactly required_len, then verify no extras
        self.out.push_str(&format!(
r#"impl<'de> ::serde::Deserialize<'de> for {name} {{
    fn deserialize<D>(de: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {{
        struct V;
        impl<'de> ::serde::de::Visitor<'de> for V {{
            type Value = {name};
            fn expecting(&self, f:&mut ::std::fmt::Formatter) -> ::std::fmt::Result {{
                write!(f, "array of fixed length {n}")
            }}
            fn visit_seq<A>(self, mut seq: A) -> ::std::result::Result<{name}, A::Error>
            where
                A: ::serde::de::SeqAccess<'de>,
            {{
"#,
            name = name,
            n = field_types.len()
        ));

        for (i, ty) in field_types.iter().enumerate() {
            self.out.push_str(&format!(
                "                let a{i}: {ty} = match seq.next_element::<{ty}>()? {{ Some(v) => v, None => return Err(::serde::de::Error::invalid_length({i}, &\"expected {n} elements\")), }};\n",
                i = i, ty = ty, n = field_types.len()
            ));
        }

        self.out.push_str(
            "                if let ::core::option::Option::Some::<::serde_json::Value>(_extra) = seq.next_element()? {\n\
                 return Err(::serde::de::Error::invalid_length(::core::usize::MAX, &\"unexpected extra elements\"));\n\
             }\n"
        );

        self.out.push_str(&format!("                Ok({name}(\n", name = name));
        for i in 0..field_types.len() {
            self.out.push_str(&format!("                    a{i},\n"));
        }
        self.out.push_str(
            "                ))\n            }\n        }\n        de.deserialize_seq(V)\n    }\n}\n\n"
        );
    }

    fn emit_len_range_tuple(&mut self, name: &str, field_types: &[String], min_len: usize, max_len: usize) {
        self.out.push_str(&format!("/// tuple len={} (required first {} slots); accepts {}..={} elements\n", field_types.len(), min_len, min_len, max_len));
        self.out.push_str(&format!("#[derive(Debug)]\npub struct {}(\n", name));
        for f in field_types {
            self.out.push_str(&format!("    pub {},\n", wrap_tuple_field(f)));
        }
        self.out.push_str(");\n\n");

        self.out.push_str(&format!(
r#"impl<'de> ::serde::Deserialize<'de> for {name} {{
    fn deserialize<D>(de: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {{
        struct V;
        impl<'de> ::serde::de::Visitor<'de> for V {{
            type Value = {name};
            fn expecting(&self, f:&mut ::std::fmt::Formatter) -> ::std::fmt::Result {{
                write!(f, "array of length {min}..={max}")
            }}
            fn visit_seq<A>(self, mut seq: A) -> ::std::result::Result<{name}, A::Error>
            where
                A: ::serde::de::SeqAccess<'de>,
            {{
"#,
            name = name, min = min_len, max = max_len
        ));

        for (i, ty) in field_types.iter().enumerate() {
            if i < min_len {
                self.out.push_str(&format!(
                    "                let a{i}: {ty} = match seq.next_element::<{ty}>()? {{ Some(v) => v, None => return Err(::serde::de::Error::invalid_length({i}, &\"at least {min} elements\")), }};\n",
                    i = i, ty = ty, min = min_len
                ));
            } else {
                if is_option_type(ty) {
                    self.out.push_str(&format!(
                        "                let a{i}: {ty} = match seq.next_element::<{ty}>()? {{ Some(v) => v, None => ::core::option::Option::None }};\n",
                        i = i, ty = ty
                    ));
                } else {
                    self.out.push_str(&format!(
                        "                let a{i}: {ty} = match seq.next_element::<{ty}>()? {{ Some(v) => v, None => return Err(::serde::de::Error::invalid_length({i}, &\"missing required element\")), }};\n",
                        i = i, ty = ty
                    ));
                }
            }
        }

        self.out.push_str(
            "                if let ::core::option::Option::Some::<::serde_json::Value>(_extra) = seq.next_element()? {\n\
                 return Err(::serde::de::Error::invalid_length(::core::usize::MAX, &\"at most the declared number of elements\"));\n\
             }\n"
        );

        self.out.push_str(&format!("                Ok({name}(\n", name = name));
        for i in 0..field_types.len() {
            self.out.push_str(&format!("                    a{i},\n"));
        }
        self.out.push_str(
            "                ))\n            }\n        }\n        de.deserialize_seq(V)\n    }\n}\n\n"
        );
    }

    // ---- unions (tagless) ----

    fn emit_union_enum_simple(&mut self, name: &str, variants: &[String], tys: &[String]) {
        // 1) the enum shell
        self.out.push_str(&format!("#[derive(Debug)]\npub enum {} {{\n", name));
        for (v, t) in variants.iter().zip(tys.iter()) {
            self.out.push_str(&format!("    {}({}),\n", v, t));
        }
        self.out.push_str("}\n\n");

        // 2) try-each-arm: parse once into ::serde_json::Value and attempt each arm
        self.out.push_str(&format!(
r#"impl<'de> ::serde::Deserialize<'de> for {name} {{
    fn deserialize<D>(de: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {{
        let val = ::serde_json::Value::deserialize(de)?;
        let mut errs: ::std::vec::Vec<(usize, &'static str, ::std::string::String)> = ::std::vec::Vec::new();
"#,
            name = name
        ));

        for (idx, (_v, t)) in variants.iter().zip(tys.iter()).enumerate() {
            self.out.push_str(&format!(
r#"        {{
            match ::serde_json::from_value::<{t}>(val.clone()) {{
                Ok(x) => return Ok({name}::V{idx}(x)),
                Err(e) => errs.push(({idx}, "{t}", e.to_string())),
            }}
        }}
"#,
                t = t, name = name, idx = idx
            ));
        }

        self.out.push_str(
r#"        if errs.is_empty() {
            return Err(::serde::de::Error::custom("no union arm matched (no errors captured)"));
        }
        let mut s = ::std::string::String::from("no union arm matched:\n");
        for (idx, ty, msg) in errs {
            s.push_str(&::std::format!("  - arm {idx} ({ty}) â†’ {msg}\n"));
        }
        Err(::serde::de::Error::custom(s))
    }
}
"#
        );
    }

    // ---- numbers ----

fn emit_int_newtype(&mut self, t: &Ty, _path: &mut Vec<String>, hint: &str) -> String {
    let Ty::Integer { min, max } = t else { unreachable!() };
    let nm = self.unique(&to_type_name(hint));

    self.out.push_str(&format!(
        "#[repr(transparent)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct {}(pub i64);\n",
        nm
    ));
    self.out.push_str(&format!(
r#"impl ::core::ops::Deref for {nm} {{
    type Target = i64;
    fn deref(&self) -> &Self::Target {{ &self.0 }}
}}
impl<'de> ::serde::Deserialize<'de> for {nm} {{
    fn deserialize<D>(de: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {{
        let x = <i64 as ::serde::Deserialize>::deserialize(de)?;
        {min_check}{max_check}
        Ok({nm}(x))
    }}
}}
"#,
        nm = nm,
        min_check = if crate::inference::CHECK_INT_BOUNDS {
            min.map(|m| format!("if x < {m} {{ return Err(::serde::de::Error::custom(\"{nm}: integer below minimum\")); }}\n        "))
               .unwrap_or_default()
        } else { String::new() },
        max_check = if crate::inference::CHECK_INT_BOUNDS {
            max.map(|m| format!("if x > {m} {{ return Err(::serde::de::Error::custom(\"{nm}: integer above maximum\")); }}\n        "))
               .unwrap_or_default()
        } else { String::new() },
    ));
    nm
}

fn emit_num_newtype(&mut self, t: &Ty, _path: &mut Vec<String>, hint: &str) -> String {
    let Ty::Number { min, max } = t else { unreachable!() };
    let nm = self.unique(&to_type_name(hint));

    self.out.push_str(&format!(
        "#[repr(transparent)]\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct {}(pub f64);\n",
        nm
    ));
    self.out.push_str(&format!(
r#"impl ::core::ops::Deref for {nm} {{
    type Target = f64;
    fn deref(&self) -> &Self::Target {{ &self.0 }}
}}
impl<'de> ::serde::Deserialize<'de> for {nm} {{
    fn deserialize<D>(de: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {{
        let x = <f64 as ::serde::Deserialize>::deserialize(de)?;
        if !x.is_finite() {{ return Err(::serde::de::Error::custom("{nm}: non-finite number")); }}
        {min_check}{max_check}
        Ok({nm}(x))
    }}
}}
"#,
        nm = nm,
        min_check = if crate::inference::CHECK_NUM_BOUNDS {
            min.map(|m| format!(
                "if !__ge_f64(x, {}) {{ return Err(::serde::de::Error::custom(\"{nm}: number below minimum\")); }}\n        ",
                f64_lit(m)
            )).unwrap_or_default()
        } else { String::new() },
        max_check = if crate::inference::CHECK_NUM_BOUNDS {
            max.map(|m| format!(
                "if !__le_f64(x, {}) {{ return Err(::serde::de::Error::custom(\"{nm}: number above maximum\")); }}\n        ",
                f64_lit(m)
            )).unwrap_or_default()
        } else { String::new() },
    ));
    nm
}


    // ---- strings ----

    fn emit_string_kind(&mut self, t: &Ty, _path: &mut Vec<String>, hint: &str) -> String {
        let Ty::String { enum_, pattern, format_uri } = t else { unreachable!() };

        // tiny enum
        if !enum_.is_empty() && enum_.len() <= 32 {
            let nm = self.unique(&to_type_name(hint));

            let mut lits: ::std::vec::Vec<::std::string::String> = enum_.iter().cloned().collect();
            lits.sort_unstable();

            let mut used: BTreeSet<String> = BTreeSet::new();
            let mut variants: ::std::vec::Vec<(String, String)> = ::std::vec::Vec::with_capacity(lits.len());
            for lit in &lits {
                let ident = variant_ident_for(lit, &mut used);
                variants.push((ident, lit.clone()));
            }

            self.out.push_str(&format!("#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum {} {{\n", nm));
            for (ident, _) in &variants {
                self.out.push_str(&format!("    {},\n", ident));
            }
            self.out.push_str("}\n");

            // Deserialize exact strings
            self.out.push_str(&format!(
                "impl<'de> ::serde::Deserialize<'de> for {nm} {{\n    fn deserialize<D>(de: D) -> ::std::result::Result<Self, D::Error>\n    where D: ::serde::Deserializer<'de> {{\n        let s = <::std::string::String as ::serde::Deserialize>::deserialize(de)?;\n        match s.as_str() {{\n"
            ));
            for (ident, lit) in &variants {
                self.out.push_str(&format!("            {lit:?} => Ok({nm}::{ident}),\n"));
            }
            self.out.push_str("            _ => Err(::serde::de::Error::unknown_variant(&s, &[])),\n        }\n    }\n}\n");

            // Serialize back to the original literal
            self.out.push_str(&format!(
                "impl ::serde::Serialize for {nm} {{\n    fn serialize<S>(&self, ser: S) -> ::std::result::Result<S::Ok, S::Error>\n    where S: ::serde::Serializer {{\n        match self {{\n"
            ));
            for (ident, lit) in &variants {
                self.out.push_str(&format!("            {nm}::{ident} => ser.serialize_str({lit:?}),\n"));
            }
            self.out.push_str("        }\n    }\n}\n\n");

            return nm;
        }

        // pattern newtype
        if let ::core::option::Option::Some(pat) = pattern {
            let nm = self.unique(&to_type_name(hint));
            self.out.push_str(&format!(
                "#[repr(transparent)]\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct {}(pub ::std::string::String);\n",
                nm
            ));
            self.out.push_str(&format!(
                r#"impl ::core::ops::Deref for {nm} {{
    type Target = ::std::string::String;
    fn deref(&self) -> &Self::Target {{ &self.0 }}
}}
"#, nm = nm));
            let rx_name = format!("RE_{}", nm.to_uppercase());
            self.out.push_str(&format!(
                "static {rx}: ::once_cell::sync::Lazy<::regex::Regex> = ::once_cell::sync::Lazy::new(|| ::regex::Regex::new({pat:?}).unwrap());\n",
                rx = rx_name
            ));
            self.out.push_str(&format!(
                r#"impl<'de> ::serde::Deserialize<'de> for {nm} {{
    fn deserialize<D>(de: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {{
        let s = <::std::string::String as ::serde::Deserialize>::deserialize(de)?;
        if !{rx}.is_match(&s) {{
            return Err(::serde::de::Error::custom("{nm}: string failed pattern"));
        }}
        Ok({nm}(s))
    }}
}}
"#,
                nm = nm,
                rx = rx_name
            ));
            return nm;
        }

        // URI newtype
        if *format_uri {
            let nm = self.unique(&to_type_name(hint));
            self.out.push_str(&format!(
                "#[repr(transparent)]\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct {}(pub ::std::string::String);\n",
                nm
            ));
            self.out.push_str(&format!(
r#"impl ::core::ops::Deref for {nm} {{
    type Target = ::std::string::String;
    fn deref(&self) -> &Self::Target {{ &self.0 }}
}}
impl<'de> ::serde::Deserialize<'de> for {nm} {{
    fn deserialize<D>(de: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {{
        let s = <::std::string::String as ::serde::Deserialize>::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {{
            return Err(::serde::de::Error::custom("{nm}: expected URI scheme"));
        }}
        Ok({nm}(s))
    }}
}}
"#, nm = nm));
            return nm;
        }

        // plain string
        "::std::string::String".into()
    }
}

// ---------- helpers ----------

fn path_with(path: &mut ::std::vec::Vec<::std::string::String>, idx: usize) -> ::std::vec::Vec<::std::string::String> {
    let mut p = path.clone();
    p.push(idx.to_string());
    p
}

fn wrap_tuple_field(t: &str) -> ::std::string::String { t.to_string() }

fn f64_lit(x: f64) -> ::std::string::String {
    if !x.is_finite() { return x.to_string(); }
    let mut s = ::std::format!("{:.15}", x);
    while s.contains('.') && s.ends_with('0') { s.pop(); }
    if s.ends_with('.') { s.push('0'); }
    if !s.contains('.') && !s.contains('e') && !s.contains('E') { s.push_str(".0"); }
    s
}

fn is_rust_keyword(s: &str) -> bool {
    matches!(
        s,
        "as" | "break" | "const" | "continue" | "crate" | "else" | "enum" | "extern" |
        "false" | "fn" | "for" | "if" | "impl" | "in" | "let" | "loop" | "match" | "mod" |
        "move" | "mut" | "pub" | "ref" | "return" | "self" | "Self" | "static" | "struct" |
        "super" | "trait" | "true" | "type" | "unsafe" | "use" | "where" | "while" |
        "async" | "await" | "dyn" | "abstract" | "become" | "box" | "do" | "final" |
        "macro" | "override" | "priv" | "typeof" | "unsized" | "virtual" | "yield" | "try"
    )
}

fn hash8(s: &str) -> ::std::string::String {
    let mut h = DefaultHasher::new();
    s.hash(&mut h);
    ::std::format!("{:08x}", (h.finish() as u32))
}

fn to_type_name(hint: &str) -> ::std::string::String {
    let mut s = ::std::string::String::with_capacity(hint.len().max(1));
    let mut up = true;
    for c in hint.chars() {
        if c.is_ascii_alphanumeric() {
            if up { s.push(c.to_ascii_uppercase()); } else { s.push(c); }
            up = false;
        } else {
            up = true;
        }
    }
    if s.is_empty() { s.push('T'); }
    if !s.chars().next().unwrap().is_ascii_alphabetic() && s.chars().next().unwrap() != '_' {
        s.insert(0, 'T');
    }
    if is_rust_keyword(&s) { s.push('_'); }
    s
}

fn to_field_name(name: &str) -> ::std::string::String {
    let mut out = ::std::string::String::new();
    let mut last_underscore = false;
    for ch in name.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(ch.to_ascii_lowercase());
            last_underscore = false;
        } else if !last_underscore {
            out.push('_');
            last_underscore = true;
        }
    }
    if out.is_empty() { out.push('_'); }
    if !out.chars().next().unwrap().is_ascii_alphabetic() && out.chars().next().unwrap() != '_' {
        out.insert(0, '_');
    }
    if is_rust_keyword(&out) { out.push('_'); }
    out
}

fn variant_ident_for(lit: &str, used: &mut BTreeSet<String>) -> ::std::string::String {
    let mut out = ::std::string::String::new();
    let mut up = true;
    for ch in lit.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(if up { ch.to_ascii_uppercase() } else { ch });
            up = false;
        } else {
            up = true;
        }
    }
    if out.is_empty() { out.push_str("V"); }
    if out.chars().next().unwrap().is_ascii_digit() { out.insert(0, 'V'); }
    if is_rust_keyword(&out) { out.push('_'); }
    if used.contains(&out) {
        out.push('_');
        out.push_str(&hash8(lit)[..6]);
    }
    used.insert(out.clone());
    out
}

fn is_option_type(s: &str) -> bool {
    let t = s.trim();
    t.starts_with("::core::option::Option<") && t.ends_with('>')
}
