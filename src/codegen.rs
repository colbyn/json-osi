use std::hash::{Hash, Hasher};
use std::collections::BTreeSet;
use std::collections::hash_map::DefaultHasher;

use crate::ir::{Field, Ty};

pub struct Codegen {
    out: String,
    // ensure stable, unique names per node path
    used: BTreeSet<String>,
}

impl Codegen {
    pub fn new() -> Self {
        Self {
            out: String::new(),
            used: BTreeSet::new(),
        }
    }
    pub fn into_string(self) -> String {
        self.out
    }

    pub fn emit(&mut self, root: &Ty, root_name: &str) {
        self.header();
        self.emit_null_type();
        self.walk(root, &mut Vec::new(), root_name.to_string());
    }

    fn header(&mut self) {
        self.out.push_str(
            r#"// AUTOGENERATED: strict types + deserializers
use serde::{Deserialize, Deserializer};
use serde::de::{Error as DeError};
"#,
        );
        self.out
            .push_str("use once_cell::sync::Lazy;\nuse regex::Regex;\n\n");
    }

    fn emit_null_type(&mut self) {
        self.out.push_str(
r#"#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Null;

impl<'de> Deserialize<'de> for Null {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        struct V;
        impl<'de> serde::de::Visitor<'de> for V {
            type Value = Null;
            fn expecting(&self, f:&mut std::fmt::Formatter) -> std::fmt::Result { write!(f, "null") }
            fn visit_unit<E>(self) -> Result<Null, E> where E: DeError { Ok(Null) }
            fn visit_none<E>(self) -> Result<Null, E> where E: DeError { Ok(Null) }
            fn visit_some<D>(self, _d: D) -> Result<Null, D::Error> where D: Deserializer<'de> {
                Err(DeError::invalid_type(serde::de::Unexpected::Other("non-null"), &"null"))
            }
        }
        de.deserialize_option(V)
    }
}
"#);
    }

    fn unique(&mut self, base: &str) -> String {
        let mut n = base.to_string();
        let mut i = 1;
        while self.used.contains(&n) {
            n = format!("{base}{i}");
            i += 1;
        }
        self.used.insert(n.clone());
        n
    }

    fn walk(&mut self, t: &Ty, path: &mut Vec<String>, hint: String) -> String {
        match t {
            Ty::Nullable(inner) => {
                let inner_name = self.walk(inner, path, hint);
                format!("Option<{}>", inner_name)
            }
            Ty::Null => "Null".into(),
            Ty::Bool => "bool".into(),
            Ty::Integer { .. } => self.emit_int_newtype(t, path, &hint),
            Ty::Number { .. } => self.emit_num_newtype(t, path, &hint),
            Ty::String { .. } => self.emit_string_kind(t, path, &hint),
            Ty::ArrayList { item, .. } => {
                let inner = self.walk(item, path, format!("{hint}Item"));
                format!("Vec<{}>", inner)
            }
            Ty::ArrayTuple {
                elems,
                min_items,
                max_items,
            } => {
                // exact arity tuple struct; serde derive enforces exact length
                let type_name = self.unique(&to_type_name(&hint));
                let fields = elems
                    .iter()
                    .enumerate()
                    .map(|(i, e)| {
                        let child_name =
                            self.walk(e, &mut path_with(path, i), format!("{hint}{}", i));
                        child_name
                    })
                    .collect::<Vec<_>>();

                // doc with min/max
                self.out.push_str(&format!(
                    "/// tuple len={} (required first {} slots)\n",
                    max_items, min_items
                ));
                self.out.push_str(&format!(
                    "#[derive(Debug, Deserialize)]\npub struct {}(\n",
                    type_name
                ));
                for f in &fields {
                    self.out
                        .push_str(&format!("    pub {},\n", wrap_tuple_field(f)));
                }
                self.out.push_str(");\n\n");
                type_name
            }
            Ty::Object { fields } => {
                let type_name = self.unique(&to_type_name(&hint));
                self.out.push_str("#[derive(Debug, Deserialize)]\n");
                self.out.push_str("#[serde(deny_unknown_fields)]\n");
                self.out.push_str(&format!("pub struct {} {{\n", type_name));
                for Field { name, ty, required } in fields {
                    let fname = to_field_name(name);
                    let mut ty_str = self.walk(ty, path, format!("{hint}{}", to_type_name(name)));
                    if !*required {
                        ty_str = format!("Option<{}>", ty_str);
                    }
                    self.out
                        .push_str(&format!("    pub {}: {},\n", fname, ty_str));
                }
                self.out.push_str("}\n\n");
                type_name
            }
            Ty::OneOf(arms) => {
                // For now: emit an enum and try each arm in order (strict).
                let type_name = self.unique(&to_type_name(&hint));
                let mut var_names = Vec::new();
                let mut arm_types = Vec::new();
                for (i, a) in arms.iter().enumerate() {
                    let vname = format!("V{}", i);
                    var_names.push(vname);
                    arm_types.push(self.walk(
                        a,
                        &mut path_with(path, i),
                        format!("{hint}Alt{}", i),
                    ));
                }
                self.emit_union_enum(&type_name, &var_names, &arm_types);
                type_name
            }
            Ty::Never => "Null".into(), // unreachable; map to Null to keep types valid
        }
    }

    fn emit_union_enum(&mut self, name: &str, variants: &[String], tys: &[String]) {
        self.out
            .push_str(&format!("#[derive(Debug)]\npub enum {} {{\n", name));
        for (v, t) in variants.iter().zip(tys.iter()) {
            self.out.push_str(&format!("    {}({}),\n", v, t));
        }
        self.out.push_str("}\n\n");

        // strict tagless union: try each arm in order
        self.out.push_str(&format!(
            r#"impl<'de> Deserialize<'de> for {name} {{
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {{
        // deserialize into a serde_json::Value once, then attempt each arm (strict)
        let val = serde_json::Value::deserialize(de)?;
"#
        ));
        for (idx, t) in tys.iter().enumerate() {
            self.out.push_str(&format!(
                "        if let Ok(x) = <{t} as serde::Deserialize>::deserialize(val.clone()) {{ return Ok({name}::{v}(x)); }}\n",
                t=t, name=name, v=variants[idx]
            ));
        }
        self.out
            .push_str("        Err(DeError::custom(\"no union arm matched\"))\n    }\n}\n\n");
    }

    fn emit_int_newtype(&mut self, t: &Ty, _path: &mut Vec<String>, hint: &str) -> String {
        let Ty::Integer { min, max } = t else {
            unreachable!()
        };
        let nm = self.unique(&to_type_name(hint));

        self.out.push_str(&format!(
        "#[repr(transparent)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct {}(pub i64);\n",
        nm
    ));
        self.out.push_str(&format!(
r#"impl std::ops::Deref for {nm} {{
    type Target = i64;
    fn deref(&self) -> &Self::Target {{ &self.0 }}
}}
impl<'de> Deserialize<'de> for {nm} {{
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {{
        let x = i64::deserialize(de)?;
        {min_check}{max_check}
        Ok({nm}(x))
    }}
}}
"#,
        nm = nm,
        min_check = min.map(|m| format!("if x < {m} {{ return Err(DeError::custom(\"{nm}: integer below minimum\")); }}\n        ")).unwrap_or_default(),
        max_check = max.map(|m| format!("if x > {m} {{ return Err(DeError::custom(\"{nm}: integer above maximum\")); }}\n        ")).unwrap_or_default(),
    ));
        nm
    }

    fn emit_num_newtype(&mut self, t: &Ty, _path: &mut Vec<String>, hint: &str) -> String {
        let Ty::Number { min, max } = t else {
            unreachable!()
        };
        let nm = self.unique(&to_type_name(hint));

        self.out.push_str(&format!(
        "#[repr(transparent)]\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct {}(pub f64);\n",
        nm
    ));
        self.out.push_str(&format!(
r#"impl std::ops::Deref for {nm} {{
    type Target = f64;
    fn deref(&self) -> &Self::Target {{ &self.0 }}
}}
impl<'de> Deserialize<'de> for {nm} {{
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {{
        let x = f64::deserialize(de)?;
        if !x.is_finite() {{ return Err(DeError::custom("{nm}: non-finite number")); }}
        {min_check}{max_check}
        Ok({nm}(x))
    }}
}}
"#,
        nm = nm,
        min_check = min.map(|m| {
            format!("if x < {} {{ return Err(DeError::custom(\"{nm}: number below minimum\")); }}\n        ", f64_lit(m))
        }).unwrap_or_default(),
        max_check = max.map(|m| {
            format!("if x > {} {{ return Err(DeError::custom(\"{nm}: number above maximum\")); }}\n        ", f64_lit(m))
        }).unwrap_or_default(),

    ));
        nm
    }

    fn emit_string_kind(&mut self, t: &Ty, _path: &mut Vec<String>, hint: &str) -> String {
        let Ty::String {
            enum_,
            pattern,
            format_uri,
        } = t
        else {
            unreachable!()
        };

        // ---------- small string enum -> Rust enum ----------
        if !enum_.is_empty() && enum_.len() <= 32 {
            let nm = self.unique(&to_type_name(hint));

            // stable order on literals
            let mut lits: Vec<String> = enum_.iter().cloned().collect();
            lits.sort_unstable();

            // Build unique, valid variant idents per-literal
            let mut used: BTreeSet<String> = BTreeSet::new();
            let mut variants: Vec<(String, String)> = Vec::with_capacity(lits.len());
            for lit in &lits {
                let ident = variant_ident_for(lit, &mut used);
                variants.push((ident, lit.clone()));
            }

            // Define enum
            self.out.push_str(&format!(
                "#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum {} {{\n", nm
            ));
            for (ident, _) in &variants {
                self.out.push_str(&format!("    {},\n", ident));
            }
            self.out.push_str("}\n");

            // Deserialize: map exact string â†’ variant
            self.out.push_str(&format!(
                "impl<'de> Deserialize<'de> for {nm} {{\n    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {{\n        let s = String::deserialize(de)?;\n        match s.as_str() {{\n"
            ));
            for (ident, lit) in &variants {
                self.out.push_str(&format!("            {lit:?} => Ok({nm}::{ident}),\n"));
            }
            self.out.push_str("            _ => Err(DeError::unknown_variant(&s, &[])),\n        }\n    }\n}\n");

            // (Optional but nice) Serialize back to the original literal
            self.out.push_str(&format!(
                "impl serde::Serialize for {nm} {{\n    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {{\n        match self {{\n"
            ));
            for (ident, lit) in &variants {
                self.out.push_str(&format!("            {nm}::{ident} => ser.serialize_str({lit:?}),\n"));
            }
            self.out.push_str("        }\n    }\n}\n\n");

            return nm;
        }


        // ---------- pattern-checked newtype ----------
        if let Some(pat) = pattern {
            let nm = self.unique(&to_type_name(hint));
            // Transparent newtype for ergonomics
            self.out.push_str(&format!(
                "#[repr(transparent)]\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct {}(pub String);\n",
                nm
            ));
            // Deref for convenient access
            self.out.push_str(&format!(
                r#"impl std::ops::Deref for {nm} {{
    type Target = String;
    fn deref(&self) -> &Self::Target {{ &self.0 }}
}}
"#,
                nm = nm
            ));
            // Compile regex once
            let rx_name = format!("RE_{}", nm.to_uppercase());
            self.out.push_str(&format!(
                "static {rx}: Lazy<Regex> = Lazy::new(|| Regex::new({pat:?}).unwrap());\n",
                rx = rx_name,
                pat = pat
            ));
            // Strict Deserialize: must match pattern
            self.out.push_str(&format!(
                r#"impl<'de> Deserialize<'de> for {nm} {{
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {{
        let s = String::deserialize(de)?;
        if !{rx}.is_match(&s) {{
            return Err(DeError::custom("{nm}: string failed pattern"));
        }}
        Ok({nm}(s))
    }}
}}
"#,
                nm = nm,
                rx = rx_name
            ));
            return nm;
        }

        // ---------- URI-checked newtype ----------
        if *format_uri {
            let nm = self.unique(&to_type_name(hint));
            self.out.push_str(&format!(
            "#[repr(transparent)]\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct {}(pub String);\n",
            nm
        ));
            self.out.push_str(&format!(
r#"impl std::ops::Deref for {nm} {{
    type Target = String;
    fn deref(&self) -> &Self::Target {{ &self.0 }}
}}
impl<'de> Deserialize<'de> for {nm} {{
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {{
        let s = String::deserialize(de)?;
        if !(s.starts_with("http://") || s.starts_with("https://") || s.starts_with("mailto:") || s.starts_with("tel:")) {{
            return Err(DeError::custom("{nm}: expected URI scheme"));
        }}
        Ok({nm}(s))
    }}
}}
"#,
                nm = nm
            ));
            return nm;
        }

        // ---------- plain string ----------
        "String".into()
    }
}

// ---------- helpers ----------

fn path_with(path: &mut Vec<String>, idx: usize) -> Vec<String> {
    let mut p = path.clone();
    p.push(idx.to_string());
    p
}

fn wrap_tuple_field(t: &str) -> String {
    // serde expects concrete types in tuple structs
    t.to_string()
}

fn f64_lit(x: f64) -> String {
    // Print with enough precision, trim trailing zeros, but always keep a decimal point.
    if !x.is_finite() {
        return x.to_string(); // shouldn't happen due to earlier checks
    }
    let mut s = format!("{:.15}", x); // 15 dp is plenty for JSON inputs
    // trim trailing zeros
    while s.contains('.') && s.ends_with('0') {
        s.pop();
    }
    // trim trailing dot -> ensure `.0`
    if s.ends_with('.') {
        s.push('0');
    }
    // if no dot (e.g., "37"), force ".0"
    if !s.contains('.') && !s.contains('e') && !s.contains('E') {
        s.push_str(".0");
    }
    s
}

// Very small keyword set (covers Rust 2021). Add more if you like.
fn is_rust_keyword(s: &str) -> bool {
    matches!(s,
        "as" | "break" | "const" | "continue" | "crate" | "else" | "enum" | "extern" |
        "false" | "fn" | "for" | "if" | "impl" | "in" | "let" | "loop" | "match" |
        "mod" | "move" | "mut" | "pub" | "ref" | "return" | "self" | "Self" |
        "static" | "struct" | "super" | "trait" | "true" | "type" | "unsafe" |
        "use" | "where" | "while" | "async" | "await" | "dyn" | "abstract" |
        "become" | "box" | "do" | "final" | "macro" | "override" | "priv" |
        "typeof" | "unsized" | "virtual" | "yield" | "try")
}

fn hash8(s: &str) -> String {
    let mut h = DefaultHasher::new();
    s.hash(&mut h);
    format!("{:08x}", (h.finish() as u32))
}

// Make a Rust *type* name: CamelCase, ensure valid start, prefix if needed.
fn to_type_name(hint: &str) -> String {
    let mut s = String::with_capacity(hint.len().max(1));
    let mut up = true;
    for c in hint.chars() {
        if c.is_ascii_alphanumeric() {
            if up {
                s.push(c.to_ascii_uppercase());
            } else {
                s.push(c);
            }
            up = false;
        } else {
            up = true;
        }
    }
    if s.is_empty() { s.push('T'); }
    // Ensure starts with letter or underscore
    if !s.chars().next().unwrap().is_ascii_alphabetic() && s.chars().next().unwrap() != '_' {
        s.insert(0, 'T');
    }
    if is_rust_keyword(&s) { s.push('_'); }
    s
}

// Make a Rust *field* name: snake_case, valid start, underscore if needed.
fn to_field_name(name: &str) -> String {
    let mut out = String::new();
    let mut last_underscore = false;
    for ch in name.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(ch.to_ascii_lowercase());
            last_underscore = false;
        } else if !last_underscore {
            out.push('_');
            last_underscore = true;
        }
    }
    if out.is_empty() { out.push('_'); }
    if !out.chars().next().unwrap().is_ascii_alphabetic() && out.chars().next().unwrap() != '_' {
        out.insert(0, '_');
    }
    if is_rust_keyword(&out) { out.push('_'); }
    out
}

// Per-enum variant ident sanitizer with collision avoidance.
fn variant_ident_for(lit: &str, used: &mut BTreeSet<String>) -> String {
    // PascalCase-ish over ASCII; replace non-alnum with boundaries.
    let mut out = String::new();
    let mut up = true;
    for ch in lit.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(if up { ch.to_ascii_uppercase() } else { ch });
            up = false;
        } else {
            up = true;
        }
    }
    if out.is_empty() {
        out.push_str("V");
    }
    // Must start with non-digit
    if out.chars().next().unwrap().is_ascii_digit() { out.insert(0, 'V'); }
    if is_rust_keyword(&out) { out.push('_'); }

    // Dedup: append short hash when collision occurs.
    if used.contains(&out) {
        out.push('_');
        out.push_str(&hash8(lit)[..6]);
    }
    used.insert(out.clone());
    out
}

