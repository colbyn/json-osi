// AUTOGENERATED: strict types + deserializers
// AUTOGENERATED: strict types + deserializers
use serde::{Deserialize, Deserializer};
use serde::de::{Error as DeError};
use once_cell::sync::Lazy;
use regex::Regex;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Null;

impl<'de> Deserialize<'de> for Null {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        struct V;
        impl<'de> serde::de::Visitor<'de> for V {
            type Value = Null;
            fn expecting(&self, f:&mut std::fmt::Formatter) -> std::fmt::Result { write!(f, "null") }
            fn visit_unit<E>(self) -> Result<Null, E> where E: DeError { Ok(Null) }
            fn visit_none<E>(self) -> Result<Null, E> where E: DeError { Ok(Null) }
            fn visit_some<D>(self, _d: D) -> Result<Null, D::Error> where D: Deserializer<'de> {
                Err(DeError::invalid_type(serde::de::Unexpected::Other("non-null"), &"null"))
            }
        }
        de.deserialize_option(V)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root0 {
    V0ahUKEa1ZQ,
    V0ahUKEa2ZQ,
}
impl<'de> Deserialize<'de> for Root0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "0ahUKEa1ZQ" => Ok(Root0::V0ahUKEa1ZQ),
            "0ahUKEa2ZQ" => Ok(Root0::V0ahUKEa2ZQ),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root0 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root0::V0ahUKEa1ZQ => ser.serialize_str("0ahUKEa1ZQ"),
            Root0::V0ahUKEa2ZQ => ser.serialize_str("0ahUKEa2ZQ"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root10 {
    IDV1354353534741,
    IDV1354413536593,
}
impl<'de> Deserialize<'de> for Root10 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "IDV1354353534741" => Ok(Root10::IDV1354353534741),
            "IDV1354413536593" => Ok(Root10::IDV1354413536593),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root10 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root10::IDV1354353534741 => ser.serialize_str("IDV1354353534741"),
            Root10::IDV1354413536593 => ser.serialize_str("IDV1354413536593"),
        }
    }
}

/// tuple len=1 (required exactly 1 element)
#[derive(Debug)]
pub struct Root1(
    pub Root10,
);

impl<'de> serde::Deserialize<'de> for Root1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct V;
        impl<'de> serde::de::Visitor<'de> for V {
            type Value = Root1;
            fn expecting(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                write!(f, "array of length 1")
            }
            fn visit_seq<A>(self, mut seq: A) -> Result<Root1, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                // read exactly one element of the declared type
                let a0: Root10 = match seq.next_element::<Root10>()? {
                    Some(v) => v,
                    None => return Err(serde::de::Error::invalid_length(0, &"exactly 1 element")),
                };
                // reject extras
                if let Some::<serde_json::Value>(_extra) = seq.next_element()? {
                    return Err(serde::de::Error::invalid_length(usize::MAX, &"exactly 1 element"));
                }
                Ok(Root1(a0))
            }
        }
        de.deserialize_seq(V)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Root2 {
    AcmeWidgets,
    AcmeWidgetsEast,
}
impl<'de> Deserialize<'de> for Root2 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        match s.as_str() {
            "Acme Widgets" => Ok(Root2::AcmeWidgets),
            "Acme Widgets East" => Ok(Root2::AcmeWidgetsEast),
            _ => Err(DeError::unknown_variant(&s, &[])),
        }
    }
}
impl serde::Serialize for Root2 {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Root2::AcmeWidgets => ser.serialize_str("Acme Widgets"),
            Root2::AcmeWidgetsEast => ser.serialize_str("Acme Widgets East"),
        }
    }
}

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root310(pub f64);
impl std::ops::Deref for Root310 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root310 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root310: non-finite number")); }
        if x < 37.420000000000002 { return Err(DeError::custom("Root310: number below minimum")); }
        if x > 37.421900000000001 { return Err(DeError::custom("Root310: number above maximum")); }
        
        Ok(Root310(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root311(pub f64);
impl std::ops::Deref for Root311 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root311 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root311: non-finite number")); }
        if x < -122.084000000000003 { return Err(DeError::custom("Root311: number below minimum")); }
        if x > -122.082999999999998 { return Err(DeError::custom("Root311: number above maximum")); }
        
        Ok(Root311(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root31(
    pub Root310,
    pub Root311,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root3(
    pub Null,
    pub Root31,
    pub Null,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root4(pub String);
impl std::ops::Deref for Root4 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT4: Lazy<Regex> = Lazy::new(|| Regex::new("^https://example\\.com[A-Za-z0-9._%+\\-]*$").unwrap());
impl<'de> Deserialize<'de> for Root4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT4.is_match(&s) {
            return Err(DeError::custom("Root4: string failed pattern"));
        }
        Ok(Root4(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root5(pub f64);
impl std::ops::Deref for Root5 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root5 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root5: non-finite number")); }
        if x < 4.3 { return Err(DeError::custom("Root5: number below minimum")); }
        if x > 4.5 { return Err(DeError::custom("Root5: number above maximum")); }
        
        Ok(Root5(x))
    }
}
/// tuple len=7 (required first 7 slots)
#[derive(Debug, Deserialize)]
pub struct Root(
    pub Root0,
    pub Root1,
    pub Root2,
    pub Root3,
    pub Option<Root4>,
    pub Root5,
    pub Option<bool>,
);




fn main() {
    let source = include_str!("./samples.json");
    let source_value = serde_json::from_str::<serde_json::Value>(&source).unwrap();
    eprintln!("▷ starting");
    for entry in source_value.as_array().unwrap() {
        let input = serde_json::to_string(&entry).unwrap();
        let _ = serde_json::from_str::<Root>(&input).unwrap();
        eprintln!("  ✔︎ success");
    }
    eprintln!("✅ finished")
}

