// AUTOGENERATED: strict types + deserializers
use serde::{Deserialize, Deserializer};
use serde::de::{Error as DeError};
use once_cell::sync::Lazy;
use regex::Regex;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Null;

impl<'de> Deserialize<'de> for Null {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        struct V;
        impl<'de> serde::de::Visitor<'de> for V {
            type Value = Null;
            fn expecting(&self, f:&mut std::fmt::Formatter) -> std::fmt::Result { write!(f, "null") }
            fn visit_unit<E>(self) -> Result<Null, E> where E: DeError { Ok(Null) }
            fn visit_none<E>(self) -> Result<Null, E> where E: DeError { Ok(Null) }
            fn visit_some<D>(self, _d: D) -> Result<Null, D::Error> where D: Deserializer<'de> {
                Err(DeError::invalid_type(serde::de::Unexpected::Other("non-null"), &"null"))
            }
        }
        de.deserialize_option(V)
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root0(pub String);
impl std::ops::Deref for Root0 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT0: Lazy<Regex> = Lazy::new(|| Regex::new("^0ahUKEa.*").unwrap());
impl<'de> Deserialize<'de> for Root0 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT0.is_match(&s) {
            return Err(DeError::custom("Root0: string failed pattern"));
        }
        Ok(Root0(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root1(pub String);
impl std::ops::Deref for Root1 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT1: Lazy<Regex> = Lazy::new(|| Regex::new("^Acme Widgets.*").unwrap());
impl<'de> Deserialize<'de> for Root1 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT1.is_match(&s) {
            return Err(DeError::custom("Root1: string failed pattern"));
        }
        Ok(Root1(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root210(pub f64);
impl std::ops::Deref for Root210 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root210 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root210: non-finite number")); }
        if x < 37.420000000000002 { return Err(DeError::custom("Root210: number below minimum")); }
        if x > 37.421900000000001 { return Err(DeError::custom("Root210: number above maximum")); }
        
        Ok(Root210(x))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root211(pub f64);
impl std::ops::Deref for Root211 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root211 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root211: non-finite number")); }
        if x < -122.084000000000003 { return Err(DeError::custom("Root211: number below minimum")); }
        if x > -122.082999999999998 { return Err(DeError::custom("Root211: number above maximum")); }
        
        Ok(Root211(x))
    }
}
/// tuple len=2 (required first 2 slots)
#[derive(Debug, Deserialize)]
pub struct Root21(
    pub Root210,
    pub Root211,
);

/// tuple len=3 (required first 3 slots)
#[derive(Debug, Deserialize)]
pub struct Root2(
    pub Null,
    pub Root21,
    pub Null,
);

#[repr(transparent)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root3(pub String);
impl std::ops::Deref for Root3 {
    type Target = String;
    fn deref(&self) -> &Self::Target { &self.0 }
}
static RE_ROOT3: Lazy<Regex> = Lazy::new(|| Regex::new("^https://example\\.com.*").unwrap());
impl<'de> Deserialize<'de> for Root3 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let s = String::deserialize(de)?;
        if !RE_ROOT3.is_match(&s) {
            return Err(DeError::custom("Root3: string failed pattern"));
        }
        Ok(Root3(s))
    }
}
#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Root4(pub f64);
impl std::ops::Deref for Root4 {
    type Target = f64;
    fn deref(&self) -> &Self::Target { &self.0 }
}
impl<'de> Deserialize<'de> for Root4 {
    fn deserialize<D>(de: D) -> Result<Self, D::Error> where D: Deserializer<'de> {
        let x = f64::deserialize(de)?;
        if !x.is_finite() { return Err(DeError::custom("Root4: non-finite number")); }
        if x < 4.3 { return Err(DeError::custom("Root4: number below minimum")); }
        if x > 4.5 { return Err(DeError::custom("Root4: number above maximum")); }
        
        Ok(Root4(x))
    }
}
/// tuple len=6 (required first 6 slots)
#[derive(Debug, Deserialize)]
pub struct Root(
    pub Root0,
    pub Root1,
    pub Root2,
    pub Option<Root3>,
    pub Root4,
    pub Option<bool>,
);


fn main() {
    let source = include_str!("./samples.json");
    let source_value = serde_json::from_str::<serde_json::Value>(&source).unwrap();
    eprintln!("▷ starting");
    for entry in source_value.as_array().unwrap() {
        let input = serde_json::to_string(&entry).unwrap();
        let _ = serde_json::from_str::<Root>(&input).unwrap();
        eprintln!("  ✔︎ success");
    }
    eprintln!("✅ finished")
}

